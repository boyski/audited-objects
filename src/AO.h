// Copyright (c) 2005-2010 David Boyce.  All rights reserved.

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef	AO_H
#define	AO_H

/// @file
/// @brief General-purpose AO declarations, macros, and typedefs

/** @mainpage AO Client
@section intro Introduction

    AO (Audited Objects) is a client/server application which tracks
    all file activity generated by a command. This file auditing is
    done by the client program, which sends its data to a central
    server for storage and sharing. The client is written in C while the
    server is in Java.  Only the client is described here; the server
    has a separate set of Javadoc pages.

@subsection what What This Is

    The user documentation for AO is stored elsewhere; this is an
    overview plus detailed API doc aimed at developers and
    maintainers.

@subsection build Build and Platform Notes

    The odds of AO "just working" on a platform to which it has not
    been specifically ported are low; auditing works at a low level and
    there are many special cases per platform. Therefore, no attempt is
    made at autoconf/automake support. Rather, there is a handcrafted
    Makefile with ifdefs per platform. This should not be seen as a big
    concern; hacking the Makefile for a new platform is by far a
    smaller task than hacking the code itself.

    In fact there are two makefiles. For Unix there is a
    <i>Makefile</i> which <b>requires GNU Make</b>. For Windows there
    is an equivalent <i>NMakefile</i> which assumes nmake and MS Visual
    Studio.

    AO is built only with GCC on Unix/Linux and with Visual Studio
    on Windows. It is possible to use other compilers but in the
    interest of simplicity we standardize on these two. On Windows,
    VS 2005 or above is required since AO uses variadic macros
    which were not supported prior to VS 2005 (aka VS 8.0).

@subsection libraries Third Party Libraries

    AO depends on a number of third-party open-source libraries
    such as libpcre and libcurl. In many cases versions of these
    will have been bundled with the build system. However, it's
    rarely a good idea to simply link with -lcurl or -lpcre and let
    the linker find the built-in versions for two primary reasons:

    First, experimentation has shown that AO is much faster when
    linked statically with its third-party libraries, and the
    safest way to ensure static linking is to build the libraries
    ourselves and build only the static variants.

    Second, even when these libraries are built statically they
    will eventually be linked into <i>our</i> shared library, and
    thus they must be built in PIC (position-independent code)
    mode. So we are in the unusual position of building
    <i>static</i> libraries out of objects compiled for use in
    <i>shared</i> libraries, and this generally requires a custom
    build.

@subsection style Coding Style Conventions

    - File naming conventions
      -# Source code is in files with short names describing their
      themes. Brevity is a virtue here; these names make no attempt
      to be clear to a novice. E.g. "ps.c" deals with PathStates.
      -# Header files have upper-case first letters. For instance
      the header for foo.c would be Foo.h. This simplifies life
      at the command line by making filename completion work better.

    - Type naming conventions
      -# Structure types end with '_s'
      -# 'Object' types end with '_o'
      -# Enumeration types end with '_e'

    - Function naming conventions
      -# Global functions in foo.c start with 'foo_'
      -# Static functions start with '_'

    - Variable conventions
      -# Variables with global or file scope use CamelCase.
      -# Automatic variables use short lower-case names.
      -# Automatic variables are declared at the top of a block.
      -# Automatic variables are not initialized in the declaration.

    - String handling conventions
      When first written, AO was coded to be buildable with wide
      (aka Unicode) characters. This has never actually been done,
      and the need to do so is no longer anticipated, but we
      continue to observe the "Windows tchar.h" conventions which
      enable wide characters:
      -# Literal strings are enclosed with the _T() macro
      -# String functions are accessed via _t* macros,
      e.g. _tcscmp() rather than strcmp().

    - Commenting conventions
      -# C++ style (//) style is allowed for short comments.
      -# Trailing comments are used rarely, if ever.

    - Doxygen conventions
      -# Exported functions, data, and types have doxygen comment
      headers while static symbols need not, though traditional
      (//) commenting is still encouraged.
      -# Items not considered worth documenting, but which would
      trigger a doxygen warning, can be enclosed with {cond,endcond}
      and a given keytword. We use "static" to indicate that the
      item, typically a macro, is of use only within the file
      containing it and is obvious enough to not need a doc comment.

    - Formatting
      -# The coding style is best described by the included GNU-indent
      config file called '.indent.pro'. All sources are submitted to
      GNU indent using those settings; contributions should be as
      well. UPDATE: unfortunately, and partly due to bugs in
      GNU indent 2.2.10, automated indenting doesn't work perfectly
      and thus the current formatting is more "inspired by" the
      .indent.pro file than actually driven by it.
      -# All if, while, and for statements use curly {} braces.

    <i>Meta-convention: in the absence of a specifically documented
      convention, do things the way the existing code does them!</i>

@subsection threads Thread Safety

    While AO does not create any threads itself, the auditor is in the
    position of a library which links into code which may do anything,
    including thread creation. Therefore defensive programming is a
    must.

    Thread safety is particularly challenging within a library which is
    forced at runtime into an executable that was not built to use it.
    For one thing, grabbing a mutex within the library may easily
    deadlock if the host process already had it.

    A less obvious complication: while POSIX has issued a standard
    (pthreads), not all implementations have reached complete parity.
    For instance, some platform versions have the pthreads API in libc
    while others have it in a separate library.  If it's in a separate
    library, the auditor may not know whether the host process is
    already linked to it (i.e. whether the host process is explicitly
    threaded). If the auditor tries to use it and it's not there,
    things will go wrong. And if we map it where it previously wasn't
    that might disturb the host process more than intended.

    All this is to say that explicit use of standard thread
    synchronization primitives, such as mutexes, within the auditor is
    problematical. Therefore we try our best to achieve thread safety
    without relying on the very interfaces which were developed for
    that purpose.

    The primary technique is to rely on the fact that, like any
    shared library, the auditor has init and fini routines (aka
    static constructors and destructors). The init routine in
    particular is called before any new threads should have been
    created. Therefore, if static data is initialized in the init
    routine and only read thereafter, no race condition can occur.

@subsection delivery Audit Data Delivery Mechanisms

    The issues around delivery of audit data are very complex. We start
    with a few design constraints:

    - Although there is not yet any <i>explicit</i> support for
    distributed builds, it's a critical principal to not design
    anything in such a way as to make such support impossible or
    hard. For instance, auditor-to-monitor communication via
    standard pipes would be discouraged since they do not work
    across hosts.

    - We also need to support parallel builds, distributed or not.
    This is NKNTW now.

    - To the degree possible we like to make the Unix and Windows
    mechanisms similar (easier said than done, vide infra).

    - Speed is, of course, critical. And there are also certain
    constraints with regard to delivery order.

    The current implementation uses standard sockets for deliveries from
    auditor to monitor; the monitor is a single-threaded process which
    sits in a select() loop and processes audit deliveries. Note that
    since the start-of-audit (SOA) record for a given command MUST be
    seen before any deliveries from its children, each command's
    audit takes two socket connections: one at startup to send the
    SOA and the other at finish time to send the actual audit data.

    To be continued ...

*/

#include "Putil/putil.h"

#include "trio.h"

/// Support for the dmalloc library...
#if defined(DMALLOC)
#include "dmalloc.h"
// #define DMALLOC_FUNC_CHECK
#endif

/// Potentially helpful for limiting exported symbols in shared library.
// Hint: Sun lint has a section showing "global, could be static".
//#ifndef AO_EXTERN
//#define AO_EXTERN extern
//#endif

/// The name of the app: used for finding properties.
#define APPLICATION_NAME		"AO"

/// Current published version of the app.
#if !defined(APPLICATION_VERSION)
#define APPLICATION_VERSION		"0.0"
#endif

/// The field separator within the audit files. This is also understood
/// on the server side - changes must be made in both places.
#define FS1				_T(",")

/// If there are fields-within-fields, this would separate them.
#define FS2				_T("+")

/// Start-of-audit-group marker for auditor->monitor communication.
#define SOA				_T("<SOA>")
/// End-of-audit-group marker for auditor->monitor communication.
#define EOA				_T("<EOA>")

/// Extended naming symbol - allows overload of PTX id on pathname.
#define XNS				_T("@@")

/// The conventional string which means "null value" in a CSV line.
#define	CSV_NULL_FIELD			_T("-")

/// A test for CSV_NULL_FIELD.
#define	CSV_FIELD_IS_NULL(s)		(!*(s) || !_tcscmp(s, CSV_NULL_FIELD))

/// The conventional radix (base) for stringifying integral values.
/// We prefer a high-numbered base for compactness.
#define CSV_RADIX			36

/// The letter codes by which we indicate file operations.
/// These are also understood on the server side - changes must be in both!
/// There are two broad categories: reads and modifications. Executing
/// a program file is considered a read op. File modifications
/// are further subdivided into write ops and link ops, which is
/// another way of describing changes to the file itself vs changes
/// to its directory such as a rename. These are conceptually quite
/// different to the filesystem but not to the application, which
/// cares only that the data available at a given path has changed.
typedef enum {
    OP_READ = 'R',		/// File read operation
    OP_EXEC = 'X',		/// File read operation
    OP_APPEND = 'A',		/// File write+modify operation
    OP_CREAT = 'C',		/// File write+modify operation
    OP_LINK = 'L',		/// File modify operation
    OP_SYMLINK = 'S',		/// File modify operation
    OP_UNLINK = 'U',		/// File modify operation
    OP_MKDIR = 'D',		/// Directory create operation
} op_e;

#if defined(_WIN32)
#define pathncmp			_tcsnicmp
#elif defined(__APPLE__)
#define pathncmp			strncasecmp
#else				/*!_WIN32 */
/// Compare path segments case-appropriately on Unix, Windows, and Mac.
#define pathncmp			strncmp
#endif	/*_WIN32*/

/// Macro representing the size of one char regardless of charset.
#define CHARSIZE			sizeof(TCHAR)

/// Generates the declaration of a setter.
#define GEN_SETTER_DECL(class, attr, type)				\
extern void class ## _set_ ## attr(class ## _o, type);

/// Generates the declaration of a getter.
#define GEN_GETTER_DECL(class, attr, type)				\
extern type class ## _get_ ## attr(class ## _o);

/// Generates a declaration for a setter/getter pair.
#define GEN_SETTER_GETTER_DECL(class, attr, type)			\
GEN_SETTER_DECL(class, attr, type)					\
GEN_GETTER_DECL(class, attr, type)

/// Generates the definition of a setter.
#define GEN_SETTER_DEFN(class, attr, type)				\
void									\
class ## _set_ ## attr(class ## _o obj, type val)			\
{									\
    obj->class ## _ ## attr = val;					\
}

/// Generates the definition of a getter for the above.
#define GEN_GETTER_DEFN(class, attr, type)				\
type									\
class ## _get_ ## attr(class ## _o obj)					\
{									\
    return obj->class ## _ ## attr;					\
}

/// Generates the definition of a setter for string values.
#define GEN_SETTER_DEFN_STR(class, attr, type)				\
void									\
class ## _set_ ## attr(class ## _o obj, type val)			\
{									\
    putil_free(obj->class ## _ ## attr);				\
    if ((val) && !CSV_FIELD_IS_NULL(val)) {				\
	obj->class ## _ ## attr = putil_strdup(val);			\
    } else {								\
	obj->class ## _ ## attr = NULL;					\
    }									\
}

/// Generates the definition of a getter for the above.
#define GEN_GETTER_DEFN_STR(class, attr, type, dflt)			\
type									\
class ## _get_ ## attr(class ## _o obj)					\
{									\
    return obj->class ## _ ## attr ? obj->class ## _ ## attr : dflt;	\
}

/// Generates the definition of a setter/getter pair.
#define GEN_SETTER_GETTER_DEFN(class, attr, type)			\
GEN_SETTER_DEFN(class, attr, type)					\
GEN_GETTER_DEFN(class, attr, type)

/// Generates the definition of a setter/getter pair for string values.
#define GEN_SETTER_GETTER_DEFN_STR(class, attr, type, dflt)		\
GEN_SETTER_DEFN_STR(class, attr, type)					\
GEN_GETTER_DEFN_STR(class, attr, type, dflt)

/// Generates the definition of a delegate getter.
#define GEN_DELEGATE_GETTER_DEFN(class, dclass, attr, type)		\
type									\
class ## _get_ ## attr(class ## _o obj)					\
{									\
    return dclass ## _get_ ## attr(class ## _get_ ## dclass(obj));	\
}

////////////////////////////////////////////////////////////////////////////
// Stuff which differs per platform ...
////////////////////////////////////////////////////////////////////////////

/// The name of the auditing shared library. Must be hard-wired so the
/// client knows what to "inject" into the audited program.
#if defined(_WIN32)
#define AUDITOR			"LibAO.dll"
#else	/*_WIN32*/
#define AUDITOR			"libAO.so"
#endif	/*_WIN32*/

// Drag these in here because (a) just about everybody needs them and
// (b) they may need to be "above" other internal headers.
#include "UTIL.h"
#include "VB.h"

#endif				/*AO_H */
